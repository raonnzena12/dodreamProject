--------------------------------------------------------------
------ RESERVE 용

INSERT INTO RESERVE VALUES (
    SEQ_RES_NO.NEXTVAL, 'testBillingKey', 1000, TO_DATE('2019-09-23 12:00:00','YYYY-MM-DD HH24:MI:SS'), 
    '배송이름', '01000000000', '01010,서울시 중구,다동', '이렇게저렇게 해주세요', 24, 54
);

INSERT INTO RESERVE VALUES (
    SEQ_RES_NO.NEXTVAL, 'testBillingKey2', 50000, TO_DATE('2019-09-23 12:00:00','YYYY-MM-DD HH24:MI:SS'), 
    '배송이름2', '01000000002', '01010,서울시 중구,다동', '이렇게저렇게 해주세요', 25, 54
);

INSERT INTO RESERVE VALUES (
    SEQ_RES_NO.NEXTVAL, 'testBillingKey3', 50000, TO_DATE('2019-09-23 12:00:00','YYYY-MM-DD HH24:MI:SS'), 
    '배송이름2', '01000000002', '01010,서울시 중구,다동', '이렇게저렇게 해주세요', 25, 54
);

INSERT INTO RESERVE VALUES (
    SEQ_RES_NO.NEXTVAL, 'testBillingKey4', 0, TO_DATE('2019-09-24 12:00:00','YYYY-MM-DD HH24:MI:SS'), 
    '이름', '01000000004', '01010,서울시 중구,다동', '배송요청사항', 30, 54, DEFAULT
);


INSERT INTO HISTORY VALUES (
 4, 5, 1
);

COMMIT;

-- HISTORY 테이블에도 추가
INSERT INTO HISTORY VALUES (
    3, 2, 1
);


--각 예약 번호별 리워드 금액 합계 조회하는 뷰
CREATE OR REPLACE VIEW RES_SUM AS
SELECT RESERVE_NO, SUM(REWARD_PRICE * REWARD_SUM) AS REWARD_PRICE_SUM FROM HISTORY
JOIN REWARD USING ( REWARD_NO )
GROUP BY RESERVE_NO
;

SELECT * FROM RES_SUM;

-- RESERVE 테이블 + 각 결제 별 금액 합계 같이 조회 해보기 + 추가 후원금까지 같이 출력
CREATE OR REPLACE VIEW RESERVE_VIEW AS
SELECT R.* , S.REWARD_PRICE_SUM, R.ADDITIONAL+S.REWARD_PRICE_SUM AS TOTAL
FROM RESERVE R
JOIN RES_SUM S ON (R.RESERVE_NO=S.RESERVE_NO);

SELECT * FROM RESERVE_VIEW;

-- 각 프로젝트별 결제금액을 같이 프린트 해볼까?
-- 왜 이렇게 한번에 잘 되는거야 나는 천재인가
CREATE OR REPLACE VIEW PROJECT_LIST_VIEW AS
SELECT P.*, C.PROJECT_CT_NAME, FLOOR(PROJECT_CLOSE_DT - SYSDATE) AS D_DAY, NVL((SELECT SUM(TOTAL) FROM RESERVE_VIEW V WHERE V.RESERVE_REF_PNO = P.PROJECT_NO GROUP BY RESERVE_REF_PNO),0) AS TOTAL
FROM PROJECT_TB P
JOIN PROJECT_CG C ON ( P.PROJECT_CT_NO = C.PROJECT_CT_NO )
WHERE PROJECT_ST_NO IN ( 4, 5 )
ORDER BY PROJECT_COUNT DESC, PROJECT_CLOSE_DT DESC;

SELECT * FROM PROJECT_LIST_VIEW
WHERE PROJECT_NO = 54;

CREATE OR REPLACE VIEW HIS_RWD_VIEW AS
SELECT * FROM HISTORY
JOIN REWARD USING ( REWARD_NO );

---------- HISTORY 테이블 INSERT 시 REWARD 테이블의 AMOUNT 재고를 감소시키는 트리거
CREATE OR REPLACE TRIGGER TRG_HIS_INSERT
AFTER INSERT
ON HISTORY
FOR EACH ROW
BEGIN
    UPDATE REWARD
    SET REWARD_AMOUNT = REWARD_AMOUNT - :NEW.REWARD_SUM
    WHERE REWARD_NO = :NEW.REWARD_NO;
END;
/

-------- HISTORY 테이블 UPDATE 시? 아님 DELETE 시? 테이블의 AMOUNT 재고를 증가시키는 트리거
----- 앗 아니다 RESERVE 테이블 RESERVE_STATUS 를 취소로 UPDATE 시 AMOUNT 재고를 증가시키자
SELECT * FROM REWARD
WHERE REWARD_NO IN (
SELECT REWARD_NO FROM HISTORY
JOIN RESERVE USING ( RESERVE_NO )
WHERE RESERVE_NO = 1);


SET SERVEROUTPUT ON;
--- 헐 설마 한번에 동작하면 떨려서 어쩌지 ;ㅁ;
-- 안된당 ㅠㅠㅠ 흑흑 변수 선언하는걸로 어케어케 해봐야지
-- 아 지금 웨어절이 여러개가 나오는데 그중에 + 할떄 연동할 REWARD_NO를 선택을 못하는구나 IF문 안에서 FOR문을 돌려봐야지
--- 얼 대박 된다 ㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠ
--- 됩니다 ㅠㅠㅠㅠㅠㅠ 되여
CREATE OR REPLACE TRIGGER TRG_RSV_UPDATE
AFTER UPDATE
ON RESERVE
FOR EACH ROW
DECLARE
    V_RWD_NO HISTORY.REWARD_NO%TYPE;
    V_RWD_SUM HISTORY.REWARD_SUM%TYPE;
    V_COUNT NUMBER;
    
    -- 커서 생성 선언
    CURSOR C1
    IS SELECT H.REWARD_NO, H.REWARD_SUM 
        FROM HISTORY H
        WHERE RESERVE_NO = :NEW.RESERVE_NO;
BEGIN
    SELECT COUNT(*)
    INTO V_COUNT
    FROM HISTORY
    WHERE RESERVE_NO = :NEW.RESERVE_NO;
    
    DBMS_OUTPUT.PUT_LINE('트리거 실행');
    DBMS_OUTPUT.PUT_LINE(:NEW.RESERVE_NO);
    
    IF :NEW.RESERVE_STATUS_NO = 3
    THEN
        DBMS_OUTPUT.PUT_LINE('더하기 동작 실행');
        OPEN C1; -- 커서 오픈
        
        LOOP
            FETCH C1 --커서 패치 : 서브쿼리의 결과에서 한 ROW씩 순서대로 데이터를 가져옴
            INTO V_RWD_NO, V_RWD_SUM;
            DBMS_OUTPUT.PUT_LINE(C1%ROWCOUNT);
            UPDATE REWARD
            SET REWARD_AMOUNT = REWARD_AMOUNT + V_RWD_SUM
            WHERE REWARD_NO = V_RWD_NO;
            DBMS_OUTPUT.PUT_LINE(V_RWD_NO||'번 리워드 의 갯수 '||V_RWD_SUM);
            EXIT WHEN V_COUNT = C1%ROWCOUNT;
            END LOOP;
        CLOSE C1;
    END IF;
END;
/

--- UPDATE TRG 테스트용 
UPDATE RESERVE
SET RESERVE_STATUS_NO = 3
WHERE RESERVE_NO = 2;

SELECT H.REWARD_NO, H.REWARD_SUM 
        FROM HISTORY H
        WHERE RESERVE_NO = 2;

ROLLBACK;
COMMIT;
SELECT REWARD_NO, REWARD_SUM FROM HISTORY
        WHERE RESERVE_NO = 3;

SELECT COUNT(*) FROM HISTORY WHERE RESERVE_NO = 1;